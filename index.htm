<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL sandbox</title>

  <link href="libs/index.css" rel="stylesheet">
  <link href="libs/css/ace_editor.css" rel="stylesheet">
  <link href="libs/css/ace_tm.css" rel="stylesheet">
  <link href="libs/css/ace_chrome.css" rel="stylesheet">

  <script src="libs/js/hand.minified-1.2.js"></script>
  <script src="libs/js/babylon.js"></script>
  <script src="libs/index.js"></script>
  <script src="libs/js/ace.js" type="text/javascript" charset="utf-8"></script>
  <script src="libs/js/fileSaver.js"></script>
  <script src="libs/js/jszip.min.js"></script>
  <script src="libs/js/theme-chrome.js"></script>
  <script src="libs/js/mode-glsl.js"></script>
</head>

<body>
<script id="vertexShaderCode" type="x-shader/x-vertex">
//  precision highp float;

// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
  gl_Position = worldViewProjection * vec4(position, 1.0);

  vUV = uv;
}
</script>
<script id="fragmentShaderCode" type="x-shader/x-fragment">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
  gl_FragColor = texture2D(textureSampler, vUV);
}
</script>

<script type="x-shader/x-vertex" id="fresnelVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 world;
uniform mat4 worldViewProjection;

// Varying
varying vec3 vPositionW;
varying vec3 vNormalW;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;
    
    vPositionW = vec3(world * vec4(position, 1.0));
    vNormalW = normalize(vec3(world * vec4(normal, 0.0)));
}
</script>

<script type="x-shader/x-fragment" id="fresnelPixel">
precision highp float;

// Lights
varying vec3 vPositionW;
varying vec3 vNormalW;

// Refs
uniform vec3 cameraPosition;
uniform sampler2D textureSampler;

void main(void) {
    vec3 color = vec3(1., 1., 1.);
    vec3 viewDirectionW = normalize(cameraPosition - vPositionW);

    // Fresnel
	  float fresnelTerm = dot(viewDirectionW, vNormalW);
	  fresnelTerm = clamp(1.0 - fresnelTerm, 0., 1.);

    gl_FragColor = vec4(color * fresnelTerm, 1.);
}
</script>

<script type="x-shader/x-vertex" id="semVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec4 vPosition;
varying vec3 vNormal;

void main() {

    vec4 p = vec4( position, 1. );

    vPosition = p;
    vNormal = normal;

    gl_Position = worldViewProjection * p;

}
</script>

<script type="x-shader/x-fragment" id="semPixel">
precision highp float;

uniform mat4 worldView;

varying vec4 vPosition;
varying vec3 vNormal;

uniform sampler2D textureSampler;
uniform sampler2D refSampler;

void main(void) {

    vec3 e = normalize( vec3( worldView * vPosition ) );
    vec3 n = normalize( worldView * vec4(vNormal, 0.0) ).xyz;

    vec3 r = reflect( e, n );
    float m = 2. * sqrt(
        pow( r.x, 2. ) +
        pow( r.y, 2. ) +
        pow( r.z + 1., 2. )
    );
    vec2 vN = r.xy / m + .5;

    vec3 base = texture2D( refSampler, vN).rgb;

    gl_FragColor = vec4( base, 1. );
}
</script>

<script type="x-shader/x-vertex" id="waveVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;

void main(void) {
    vec3 v = position;
    v.x += sin(2.0 * position.y + (time)) * 0.5;
    
    gl_Position = worldViewProjection * vec4(v, 1.0);
    
    vPosition = position;
    vNormal = normal;
    vUV = uv;
}
</script>

<script type="x-shader/x-vertex" id="basicVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="basicPixel">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
    gl_FragColor = texture2D(textureSampler, vUV);
}
</script>

<script type="x-shader/x-vertex" id="bwVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="bwPixel">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
    float luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));
    gl_FragColor = vec4(luminance, luminance, luminance, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="cellShadingVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 world;
uniform mat4 worldViewProjection;

// Varying
varying vec3 vPositionW;
varying vec3 vNormalW;
varying vec2 vUV;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;
    
    vPositionW = vec3(world * vec4(position, 1.0));
    vNormalW = normalize(vec3(world * vec4(normal, 0.0)));
    
    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="cellShadingPixel">
precision highp float;

// Lights
varying vec3 vPositionW;
varying vec3 vNormalW;
varying vec2 vUV;

// Refs
uniform sampler2D textureSampler;

void main(void) {
    float ToonThresholds[4];
    ToonThresholds[0] = 0.95;
    ToonThresholds[1] = 0.5;
    ToonThresholds[2] = 0.2;
    ToonThresholds[3] = 0.03;
    
    float ToonBrightnessLevels[5];
    ToonBrightnessLevels[0] = 1.0;
    ToonBrightnessLevels[1] = 0.8;
    ToonBrightnessLevels[2] = 0.6;
    ToonBrightnessLevels[3] = 0.35;
    ToonBrightnessLevels[4] = 0.2;
    
    vec3 vLightPosition = vec3(0,20,10);
    
    // Light
    vec3 lightVectorW = normalize(vLightPosition - vPositionW);
    
    // diffuse
    float ndl = max(0., dot(vNormalW, lightVectorW));
    
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    if (ndl > ToonThresholds[0])
    {
        color *= ToonBrightnessLevels[0];
    }
    else if (ndl > ToonThresholds[1])
    {
        color *= ToonBrightnessLevels[1];
    }
    else if (ndl > ToonThresholds[2])
    {
        color *= ToonBrightnessLevels[2];
    }
    else if (ndl > ToonThresholds[3])
    {
        color *= ToonBrightnessLevels[3];
    }
    else
    {
        color *= ToonBrightnessLevels[4];
    }
    
    gl_FragColor = vec4(color, 1.);
}
</script>

<script type="x-shader/x-vertex" id="phongVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;
    
    vUV = uv;
    vPosition = position;
    vNormal = normal;
}
</script>

<script type="x-shader/x-fragment" id="phongPixel">
precision highp float;

// Varying
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;

// Uniforms
uniform mat4 world;

// Refs
uniform vec3 cameraPosition;
uniform sampler2D textureSampler;

void main(void) {
    vec3 vLightPosition = vec3(0,20,10);
    
    // World values
    vec3 vPositionW = vec3(world * vec4(vPosition, 1.0));
    vec3 vNormalW = normalize(vec3(world * vec4(vNormal, 0.0)));
    vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
    
    // Light
    vec3 lightVectorW = normalize(vLightPosition - vPositionW);
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    // diffuse
    float ndl = max(0., dot(vNormalW, lightVectorW));
    
    // Specular
    vec3 angleW = normalize(viewDirectionW + lightVectorW);
    float specComp = max(0., dot(vNormalW, angleW));
    specComp = pow(specComp, max(1., 64.)) * 2.;
    
    gl_FragColor = vec4(color * ndl + vec3(specComp), 1.);
}
</script>

<script type="x-shader/x-vertex" id="discardVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;

    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="discardPixel">
precision highp float;

varying vec2 vUV;

// Refs
uniform sampler2D textureSampler;

void main(void) {
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    if (color.g > 0.5) {
        discard;
    }
    
    gl_FragColor = vec4(color, 1.);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_noLight_vret">
// Attributes
attribute vec3 position;

// Uniforms
uniform mat4 worldViewProjection;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_noLight_frag">
#ifdef GL_ES
    precision highp float;
#endif

void main(void) {
    gl_FragColor = vec4(1.0, 0.5, 0.31, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_flat_vret">
// Attributes
attribute vec3 position;

// Uniforms
uniform mat4 worldViewProjection;

void main(void) {
    vec3 pos = position;
    pos.z = .0;
    gl_Position = worldViewProjection * vec4(pos, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_flat_frag">
#ifdef GL_ES
    precision highp float;
#endif

void main(void) {
    gl_FragColor = vec4(1.0, 0.5, 0.31, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_simplestList_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec3 vNormal;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNormal = normalize(normal);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_simplestList_frag">
#ifdef GL_ES
    precision highp float;
#endif

vec3 lightColor = vec3(1.0, 0.0, 0.0);
vec3 lightDir = vec3(0.0, 0.0, 4.0);

varying vec3 vNormal;

void main(void) {
    vec3 color = clamp( dot( normalize(vNormal), lightDir ), 0.0, 1.0 ) * lightColor;

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_perVertexLighting_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;

// Varying
varying vec3 vColor;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    vec3 lightDir;
    vec3 diffuse, ambient, specular, globalAmbient;
    float NdotL, NdotHV;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    lightDir = L;

    // diffuse
    diffuse = materialDiffuse * lightDiffuse;

    // ambient
    ambient = materialAmbient * lightAmbient;

    // specular
    NdotL = max( dot( normal, lightDir ), 0.0 );
    if (NdotL > 0.0) {
        NdotHV = max( dot( normal, H ), 0.0 );
        specular = materialSpecular * lightSpecular * pow( NdotHV, materialShininess );
    } else {
        specular = vec3(0.0);
    }
    diffuse *= NdotL;

    vColor = diffuse + ambient + specular;

    gl_Position = worldViewProjection * vec4(position, 1.0);

}
</script>
<script type="x-shader/x-fragment" id="basicLight_perVertexLighting_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vColor;

void main(void) {
    gl_FragColor = vec4(vColor, 1.0);
}
</script>


<script type="x-shader/x-vertex" id="basicLight_perPixelLighting_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;

// Varying
varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    vNormal = normal;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    vLightDir = L;

    vHalfVector = H;

    // diffuse
    vDiffuse = materialDiffuse * lightDiffuse;

    // ambient
    vAmbient = materialAmbient * lightAmbient;

    gl_Position = worldViewProjection * vec4(position, 1.0);

}
</script>
<script type="x-shader/x-fragment" id="basicLight_perPixelLighting_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    float NdotL, NdotHV;

    vec3 color = vec3(0.0);

    // ambient
    color += vAmbient;

    NdotL = max( dot( vNormal, vLightDir ), 0.0 );
    if (NdotL > 0.0) {
        // diffuse
        color += vDiffuse * NdotL;

        // specular
        NdotHV = max( dot( vNormal, vHalfVector ), 0.0 );
        color += materialSpecular * lightSpecular * pow( NdotHV, materialShininess );
    }


    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_pointLight_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;
uniform mat4 worldView;
uniform float time;

// Varying
varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

// lightParameters
vec3 lightPosition = vec3(4.0, 2.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    lightPosition.x = cos(time) * 4.0;
    lightPosition.z = sin(time) * 4.0;

    vNormal = normal;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    vLightDir = L;

    vHalfVector = H;

    // diffuse
    vDiffuse = materialDiffuse * lightDiffuse;

    // ambient
    vAmbient = materialAmbient * lightAmbient;

    gl_Position = worldViewProjection * vec4(position, 1.0);

    vec4 ecPos;
    vec3 aux;
    ecPos = worldView * vec4(position, 1.0);
    aux = lightPosition - vec3(ecPos);
    vDist = length(aux);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_pointLight_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

float lightConstantAttenuation = 0.1;
float lightLinearAttenuation = 0.05;
float lightQuadraticAttenuation = 0.025;

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    float NdotL, NdotHV;
    float att;

    vec3 color = vec3(0.0);

    // ambient
    color += vAmbient;

    NdotL = max( dot( vNormal, vLightDir ), 0.0 );
    if (NdotL > 0.0) {
        att = 1.0 / (lightConstantAttenuation + lightLinearAttenuation * vDist + lightQuadraticAttenuation * vDist * vDist);

        // diffuse
        color += vDiffuse * NdotL;

        // specular
        NdotHV = max( dot( vNormal, vHalfVector ), 0.0 );
        color += materialSpecular * lightSpecular * pow( NdotHV, materialShininess );

        color *= att;
    }


    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_spotLight_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;
uniform mat4 worldView;

// Varying
varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    vNormal = normal;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    vLightDir = L;

    vHalfVector = H;

    // diffuse
    vDiffuse = materialDiffuse * lightDiffuse;

    // ambient
    vAmbient = materialAmbient * lightAmbient;

    gl_Position = worldViewProjection * vec4(position, 1.0);

    vec4 ecPos;
    vec3 aux;
    ecPos = worldView * vec4(position, 1.0);
    aux = lightPosition - vec3(ecPos);
    vDist = length(aux);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_spotLight_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

uniform float time;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

float lightConstantAttenuation = 0.1;
float lightLinearAttenuation = 0.05;
float lightQuadraticAttenuation = 0.025;

float lightSpotCosCutoff = 0.75;
vec3 lightSpotDirection = vec3(-4.0, -4.0, -4.0);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    lightSpotDirection.x = cos(time) * -4.0;
    lightSpotDirection.z = sin(time) * -4.0;

    float NdotL, NdotHV;
    float att, spotEffect;

    vec3 color = vec3(0.0);

    // ambient
    color += vAmbient;

    NdotL = max( dot( vNormal, vLightDir ), 0.0 );
    if (NdotL > 0.0) {
        spotEffect = dot( normalize( lightSpotDirection ), normalize(-vLightDir) );

        if (spotEffect > lightSpotCosCutoff) {
            att = 1.0 / (lightConstantAttenuation + lightLinearAttenuation * vDist + lightQuadraticAttenuation * vDist * vDist);

            // diffuse
            color += vDiffuse * NdotL;

            // specular
            NdotHV = max( dot( vNormal, vHalfVector ), 0.0 );
            color += materialSpecular * lightSpecular * pow( NdotHV, materialShininess );

            color *= att;
        }
    }

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_basicTexture_vret">
// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
}
</script>
<script type="x-shader/x-fragment" id="basicLight_basicTexture_frag">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
    gl_FragColor = texture2D(textureSampler, vUV);
}
</script>

<script type="x-shader/x-vertex" id="npr_tone_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec3 vNormal;

void main() {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNormal = normal;
}
</script>
<script type="x-shader/x-fragment" id="npr_tone_frag">
// Varying
varying vec3 vNormal;

vec3 diffuseColor = vec3(1.0, 0.5, 0.31);
vec3 phongColor = vec3(1.0, 0.7, 0.52);
float edge = 0.5;
float phong = 0.9;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    vec3 color = diffuseColor;
    float intensity = dot( lightPosition, vNormal );
    if ( abs( intensity ) < edge ) {
        color = vec3(0.0);
    }
    if ( intensity > phong ) {
        color = phongColor;
    }
    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="npr_hatch_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying vec3 vNormal;
varying vec2 vUV;
varying float vLightIntensity;
varying float vV;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    vec3 pos = vec3(worldViewProjection * vec4(position, 1.0));
    vec3 tnorm = normalize( normal );
    vec3 lightDir = normalize( lightPosition - position );

    vLightIntensity = max( dot( lightDir, tnorm ), 0.0 );

    if(uv.s == 0.0 && uv.t == 0.0) {
        vV = pos.y;
    } else {
        vV = uv.t;
    }

    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNormal = normal;
    vUV = uv;
}
</script>
<script type="x-shader/x-fragment" id="npr_hatch_frag">
// Varying
varying vec3 vNormal;
varying vec2 vUV;
varying float vLightIntensity;
varying float vV;

const float frequency = 1.0;

float sWidth = 10.0;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    float dp = length( vec2( dFdx(vV * sWidth), dFdy(vV * sWidth) ) );
    float logdp = -log2(dp);
    float ilogdp = floor(logdp);
    float stripes = exp2(ilogdp);
    float noise = rand(vUV);
    float sawtooth = fract( (vV + noise * 0.01) * frequency * stripes );
    float triangle = abs( 2.0 * sawtooth - 1.0 );
    float transition = logdp - ilogdp;
    triangle = abs( (1.0 + transition) * triangle - transition );

    const float edgeW = 0.2;
    float edge0 = clamp( vLightIntensity - edgeW, 0.0, 1.0 );
    float edge1 = clamp( vLightIntensity, 0.0, 1.0 );

    float square = 1.0 - smoothstep(edge0, edge1, triangle);

    gl_FragColor = vec4(vec3(square), 1.0);
}
</script>

<script type="x-shader/x-vertex" id="npr_gooch_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying float vNdotL;
varying vec3 vReflectVec;
varying vec3 vViewVec;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    vec3 pos = vec3(worldViewProjection * vec4(position, 1.0));
    vec3 tnorm = normalize( normal );
    vec3 lightDir = normalize( lightPosition - position );

    vReflectVec = normalize( reflect( -lightDir, tnorm ) );
    vViewVec = normalize( -pos );
    vNdotL = ( dot( lightDir, tnorm ) + 1.0 ) * 0.5;

    gl_Position = worldViewProjection * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="npr_gooch_frag">
// Varying
varying float vNdotL;
varying vec3 vReflectVec;
varying vec3 vViewVec;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

vec3 surfaceColor = vec3(1.0, 0.5, 0.31);
vec3 warmColor = vec3(1.0, 0.1, 0.0);
vec3 coolColor = vec3(0.0, 0.1, 1.0);
float diffuseWarm = 0.2;
float diffuseCool = 0.1;

void main() {
    vec3 kCool = min(coolColor + diffuseCool * surfaceColor, 1.0);
    vec3 kWarm = min(warmColor + diffuseWarm * surfaceColor, 1.0);
    vec3 kFinal = mix(kCool, kWarm, vNdotL);

    vec3 nReflect = normalize(vReflectVec);
    vec3 nView = normalize(vViewVec);

    float spec = max( dot(nReflect, nView), 0.0 );
    spec = pow(spec, 32.0);

    gl_FragColor = vec4(min(kFinal + spec, 1.0), 1.0);
}
</script>

<script type="x-shader/x-vertex" id="npr_PolkaDot_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying float vLghtIntensity;
varying vec3 vPosition;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);
float specularContribution = 0.7;

void main() {
    vec3 pos = vec3(worldViewProjection * vec4(position, 1.0));
    vec3 tnorm = normalize( normal );
    vec3 lightDir = normalize( lightPosition - position );

    vec3 reflectVec = normalize( reflect( -lightDir, tnorm ) );
    vec3 viewVec = normalize( -pos );

    float diffuseContribution = 1.0 - specularContribution;

    float diffuse = max( dot(lightDir, tnorm), 0.0 );
    float specular = 0.0;
    if (diffuse > 0.0) {
        specular = max( dot(reflectVec, viewVec), 0.0 );
        specular = pow( specular, 16.0 );
    }

    vLghtIntensity = diffuseContribution * diffuse * 1.5 + specularContribution * specular;

    vPosition = position;

    gl_Position = worldViewProjection * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="npr_PolkaDot_frag">
// Varying
varying float vLghtIntensity;
varying vec3 vPosition;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

vec3 spacing = vec3(0.3, 0.3, 0.25);
float dotSize = 0.1;
vec3 modelColor = vec3(1.0);
vec3 PolkaDotColor = vec3(0.0);

void main() {
    float insideSphere, sphereRadius, scaledPointLength;
    vec3 scaledPoint, finalColor;

    scaledPoint = vPosition - (spacing * floor( vPosition / spacing ));
    scaledPoint = scaledPoint - spacing / 2.0;
    scaledPointLength = length(scaledPoint);
    insideSphere = step(scaledPointLength, dotSize);
    finalColor = vec3( mix( modelColor, PolkaDotColor, insideSphere ) );

    gl_FragColor = clamp( vec4(finalColor * vLghtIntensity, 1.0), 0.0, 1.0 );
}
</script>

<div id="outerContainer">
  <div id="subHeaderBackground">
    <div id="templateDropdown" class="dropdownContainer">
      <div class="dropdownLabel">Templates:</div>
      <div class="dropdownSelectContainer">
        <select id="templates">

          <optgroup label="渲染光照">
            <option value="noLight" selected>没有光照(纯色)</option>
            <option value="flat">偏平渲染</option>
            <option value="simplestLight">最简单光照</option>
            <option value="perVertexLighting">逐顶点光照</option>
            <option value="perPixelLighting">逐像素光照</option>
            <option value="pointLight">点光源</option>
            <option value="spotLight">聚光灯</option>
            <option value="basicTexture">加载纹理</option>
          </optgroup>

          <optgroup label="非真实感渲染(NPR)">
            <option value="tone">卡通渲染</option>
            <option value="hatch">影线渲染</option>
            <option value="gooch">Gooch渲染</option>
            <option value="PolkaDot">波尔卡圆点渲染</option>
          </optgroup>

          <!--<option selected>Basic</option>-->
          <!--<option>Black and white</option>-->
          <!--<option>Cell shading</option>-->
          <!--<option>Phong</option>-->
          <!--<option>Discard</option>-->
          <!--<option>Wave</option>-->
          <!--<option>Spherical environment mapping</option>-->
          <!--<option>Fresnel</option>-->
        </select>
      </div>
    </div>
    <div id="meshDropdown" class="dropdownContainer">
      <div class="dropdownLabel">Meshes:</div>
      <div class="dropdownSelectContainer">
        <select id="meshes">
          <option>Sphere</option>
          <option>Torus</option>
          <option>Box</option>
          <option selected="">Torus Knot</option>
          <option>Ground</option>
          <option>schooner</option>
          <option>Tree</option>
          <option>teapot</option>
          <option>monkey</option>
        </select>
      </div>
    </div>
    <div id="buttons">
      <div id="compileButton" class="circleButton" title="Compile"></div>
    </div>
  </div>
  <div id="shadersContainer" style="background-color: green;">
    <div id="vertexRow" class="row">
      <div class="rowHeader">
        <span class="headerTitle">VERTEX SHADER</span>
      </div>
      <div class="rowEditor">
        <div class="shaderCode ace_editor ace-chrome" id="vertexShaderEditor">
          <textarea class="ace_text-input"
                    wrap="off" autocapitalize="off"
                    spellcheck="false"
                    style="opacity: 0; height: 16px; width: 7.20312px; right: 875.797px; bottom: 526px;"></textarea>
        </div>
      </div>
    </div>
    <div id="fragmentRow" class="row">
      <div class="rowHeader">
        <span class="headerTitle">PIXEL (FRAGMENT) SHADER</span>
      </div>
      <div class="rowEditor">
        <div class="shaderCode ace_editor ace-chrome" id="fragmentShaderEditor">
          <textarea class="ace_text-input"
                                                                                          wrap="off"
                                                                                          autocapitalize="off"
                                                                                          spellcheck="false"
                                                                                          style="opacity: 0; height: 16px; width: 7.20312px; right: 882.797px; bottom: 526px;"></textarea>
        </div>
      </div>
    </div>
  </div>
  <div id="renderContainer">
    <div id="loading" class="hidden">Loading...</div>
    <div id="renderCanvasContainer">
      <canvas id="renderCanvas" width="935" height="993" tabindex="1"></canvas>
    </div>
    <div id="errorLog"></div>
  </div>
</div>


</body>
</html>