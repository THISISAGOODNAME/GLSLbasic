<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL sandbox</title>

  <link href="libs/index.css" rel="stylesheet">
  <link href="libs/css/ace_editor.css" rel="stylesheet">
  <link href="libs/css/ace_tm.css" rel="stylesheet">
  <link href="libs/css/ace_chrome.css" rel="stylesheet">

  <script src="libs/js/hand.minified-1.2.js"></script>
  <script src="libs/js/babylon.js"></script>
  <script src="libs/index.js"></script>
  <script src="libs/js/ace.js" type="text/javascript" charset="utf-8"></script>
  <script src="libs/js/fileSaver.js"></script>
  <script src="libs/js/jszip.min.js"></script>
  <script src="libs/js/theme-chrome.js"></script>
  <script src="libs/js/mode-glsl.js"></script>
</head>

<body>
<script id="vertexShaderCode" type="x-shader/x-vertex">
//  precision highp float;

// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
  gl_Position = worldViewProjection * vec4(position, 1.0);

  vUV = uv;
}
</script>
<script id="fragmentShaderCode" type="x-shader/x-fragment">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
  gl_FragColor = texture2D(textureSampler, vUV);
}
</script>

<script type="x-shader/x-vertex" id="fresnelVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 world;
uniform mat4 worldViewProjection;

// Varying
varying vec3 vPositionW;
varying vec3 vNormalW;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;
    
    vPositionW = vec3(world * vec4(position, 1.0));
    vNormalW = normalize(vec3(world * vec4(normal, 0.0)));
}
</script>

<script type="x-shader/x-fragment" id="fresnelPixel">
precision highp float;

// Lights
varying vec3 vPositionW;
varying vec3 vNormalW;

// Refs
uniform vec3 cameraPosition;
uniform sampler2D textureSampler;

void main(void) {
    vec3 color = vec3(1., 1., 1.);
    vec3 viewDirectionW = normalize(cameraPosition - vPositionW);

    // Fresnel
	  float fresnelTerm = dot(viewDirectionW, vNormalW);
	  fresnelTerm = clamp(1.0 - fresnelTerm, 0., 1.);

    gl_FragColor = vec4(color * fresnelTerm, 1.);
}
</script>

<script type="x-shader/x-vertex" id="semVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec4 vPosition;
varying vec3 vNormal;

void main() {

    vec4 p = vec4( position, 1. );

    vPosition = p;
    vNormal = normal;

    gl_Position = worldViewProjection * p;

}
</script>

<script type="x-shader/x-fragment" id="semPixel">
precision highp float;

uniform mat4 worldView;

varying vec4 vPosition;
varying vec3 vNormal;

uniform sampler2D textureSampler;
uniform sampler2D refSampler;

void main(void) {

    vec3 e = normalize( vec3( worldView * vPosition ) );
    vec3 n = normalize( worldView * vec4(vNormal, 0.0) ).xyz;

    vec3 r = reflect( e, n );
    float m = 2. * sqrt(
        pow( r.x, 2. ) +
        pow( r.y, 2. ) +
        pow( r.z + 1., 2. )
    );
    vec2 vN = r.xy / m + .5;

    vec3 base = texture2D( refSampler, vN).rgb;

    gl_FragColor = vec4( base, 1. );
}
</script>

<script type="x-shader/x-vertex" id="waveVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;

void main(void) {
    vec3 v = position;
    v.x += sin(2.0 * position.y + (time)) * 0.5;
    
    gl_Position = worldViewProjection * vec4(v, 1.0);
    
    vPosition = position;
    vNormal = normal;
    vUV = uv;
}
</script>

<script type="x-shader/x-vertex" id="basicVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="basicPixel">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
    gl_FragColor = texture2D(textureSampler, vUV);
}
</script>

<script type="x-shader/x-vertex" id="bwVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="bwPixel">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
    float luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));
    gl_FragColor = vec4(luminance, luminance, luminance, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="cellShadingVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 world;
uniform mat4 worldViewProjection;

// Varying
varying vec3 vPositionW;
varying vec3 vNormalW;
varying vec2 vUV;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;
    
    vPositionW = vec3(world * vec4(position, 1.0));
    vNormalW = normalize(vec3(world * vec4(normal, 0.0)));
    
    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="cellShadingPixel">
precision highp float;

// Lights
varying vec3 vPositionW;
varying vec3 vNormalW;
varying vec2 vUV;

// Refs
uniform sampler2D textureSampler;

void main(void) {
    float ToonThresholds[4];
    ToonThresholds[0] = 0.95;
    ToonThresholds[1] = 0.5;
    ToonThresholds[2] = 0.2;
    ToonThresholds[3] = 0.03;
    
    float ToonBrightnessLevels[5];
    ToonBrightnessLevels[0] = 1.0;
    ToonBrightnessLevels[1] = 0.8;
    ToonBrightnessLevels[2] = 0.6;
    ToonBrightnessLevels[3] = 0.35;
    ToonBrightnessLevels[4] = 0.2;
    
    vec3 vLightPosition = vec3(0,20,10);
    
    // Light
    vec3 lightVectorW = normalize(vLightPosition - vPositionW);
    
    // diffuse
    float ndl = max(0., dot(vNormalW, lightVectorW));
    
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    if (ndl > ToonThresholds[0])
    {
        color *= ToonBrightnessLevels[0];
    }
    else if (ndl > ToonThresholds[1])
    {
        color *= ToonBrightnessLevels[1];
    }
    else if (ndl > ToonThresholds[2])
    {
        color *= ToonBrightnessLevels[2];
    }
    else if (ndl > ToonThresholds[3])
    {
        color *= ToonBrightnessLevels[3];
    }
    else
    {
        color *= ToonBrightnessLevels[4];
    }
    
    gl_FragColor = vec4(color, 1.);
}
</script>

<script type="x-shader/x-vertex" id="phongVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;
    
    vUV = uv;
    vPosition = position;
    vNormal = normal;
}
</script>

<script type="x-shader/x-fragment" id="phongPixel">
precision highp float;

// Varying
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUV;

// Uniforms
uniform mat4 world;

// Refs
uniform vec3 cameraPosition;
uniform sampler2D textureSampler;

void main(void) {
    vec3 vLightPosition = vec3(0,20,10);
    
    // World values
    vec3 vPositionW = vec3(world * vec4(vPosition, 1.0));
    vec3 vNormalW = normalize(vec3(world * vec4(vNormal, 0.0)));
    vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
    
    // Light
    vec3 lightVectorW = normalize(vLightPosition - vPositionW);
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    // diffuse
    float ndl = max(0., dot(vNormalW, lightVectorW));
    
    // Specular
    vec3 angleW = normalize(viewDirectionW + lightVectorW);
    float specComp = max(0., dot(vNormalW, angleW));
    specComp = pow(specComp, max(1., 64.)) * 2.;
    
    gl_FragColor = vec4(color * ndl + vec3(specComp), 1.);
}
</script>

<script type="x-shader/x-vertex" id="discardVertex">
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    vec4 outPosition = worldViewProjection * vec4(position, 1.0);
    gl_Position = outPosition;

    vUV = uv;
}
</script>

<script type="x-shader/x-fragment" id="discardPixel">
precision highp float;

varying vec2 vUV;

// Refs
uniform sampler2D textureSampler;

void main(void) {
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    if (color.g > 0.5) {
        discard;
    }
    
    gl_FragColor = vec4(color, 1.);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_noLight_vret">
// Attributes
attribute vec3 position;

// Uniforms
uniform mat4 worldViewProjection;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_noLight_frag">
#ifdef GL_ES
    precision highp float;
#endif

void main(void) {
    gl_FragColor = vec4(1.0, 0.5, 0.31, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_flat_vret">
// Attributes
attribute vec3 position;

// Uniforms
uniform mat4 worldViewProjection;

void main(void) {
    vec3 pos = position;
    pos.z = .0;
    gl_Position = worldViewProjection * vec4(pos, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_flat_frag">
#ifdef GL_ES
    precision highp float;
#endif

void main(void) {
    gl_FragColor = vec4(1.0, 0.5, 0.31, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_simplestList_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec3 vNormal;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNormal = normalize(normal);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_simplestList_frag">
#ifdef GL_ES
    precision highp float;
#endif

vec3 lightColor = vec3(1.0, 0.0, 0.0);
vec3 lightDir = vec3(0.0, 0.0, 4.0);

varying vec3 vNormal;

void main(void) {
    vec3 color = clamp( dot( normalize(vNormal), lightDir ), 0.0, 1.0 ) * lightColor;

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_perVertexLighting_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;

// Varying
varying vec3 vColor;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    vec3 lightDir;
    vec3 diffuse, ambient, specular, globalAmbient;
    float NdotL, NdotHV;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    lightDir = L;

    // diffuse
    diffuse = materialDiffuse * lightDiffuse;

    // ambient
    ambient = materialAmbient * lightAmbient;

    // specular
    NdotL = max( dot( normal, lightDir ), 0.0 );
    if (NdotL > 0.0) {
        NdotHV = max( dot( normal, H ), 0.0 );
        specular = materialSpecular * lightSpecular * pow( NdotHV, materialShininess );
    } else {
        specular = vec3(0.0);
    }
    diffuse *= NdotL;

    vColor = diffuse + ambient + specular;

    gl_Position = worldViewProjection * vec4(position, 1.0);

}
</script>
<script type="x-shader/x-fragment" id="basicLight_perVertexLighting_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vColor;

void main(void) {
    gl_FragColor = vec4(vColor, 1.0);
}
</script>


<script type="x-shader/x-vertex" id="basicLight_perPixelLighting_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;

// Varying
varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    vNormal = normal;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    vLightDir = L;

    vHalfVector = H;

    // diffuse
    vDiffuse = materialDiffuse * lightDiffuse;

    // ambient
    vAmbient = materialAmbient * lightAmbient;

    gl_Position = worldViewProjection * vec4(position, 1.0);

}
</script>
<script type="x-shader/x-fragment" id="basicLight_perPixelLighting_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    float NdotL, NdotHV;

    vec3 color = vec3(0.0);

    // ambient
    color += vAmbient;

    NdotL = max( dot( vNormal, vLightDir ), 0.0 );
    if (NdotL > 0.0) {
        // diffuse
        color += vDiffuse * NdotL;

        // specular
        NdotHV = max( dot( vNormal, vHalfVector ), 0.0 );
        color += materialSpecular * lightSpecular * pow( NdotHV, materialShininess );
    }


    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_pointLight_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;
uniform mat4 worldView;
uniform float time;

// Varying
varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

// lightParameters
vec3 lightPosition = vec3(4.0, 2.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    lightPosition.x = cos(time) * 4.0;
    lightPosition.z = sin(time) * 4.0;

    vNormal = normal;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    vLightDir = L;

    vHalfVector = H;

    // diffuse
    vDiffuse = materialDiffuse * lightDiffuse;

    // ambient
    vAmbient = materialAmbient * lightAmbient;

    gl_Position = worldViewProjection * vec4(position, 1.0);

    vec4 ecPos;
    vec3 aux;
    ecPos = worldView * vec4(position, 1.0);
    aux = lightPosition - vec3(ecPos);
    vDist = length(aux);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_pointLight_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

float lightConstantAttenuation = 0.1;
float lightLinearAttenuation = 0.05;
float lightQuadraticAttenuation = 0.025;

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    float NdotL, NdotHV;
    float att;

    vec3 color = vec3(0.0);

    // ambient
    color += vAmbient;

    NdotL = max( dot( vNormal, vLightDir ), 0.0 );
    if (NdotL > 0.0) {
        att = 1.0 / (lightConstantAttenuation + lightLinearAttenuation * vDist + lightQuadraticAttenuation * vDist * vDist);

        // diffuse
        color += vDiffuse * NdotL;

        // specular
        NdotHV = max( dot( vNormal, vHalfVector ), 0.0 );
        color += materialSpecular * lightSpecular * pow( NdotHV, materialShininess );

        color *= att;
    }


    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_spotLight_vret">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;
uniform vec3 cameraPosition;
uniform mat4 worldView;

// Varying
varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    vNormal = normal;

    vec3 L = normalize(lightPosition - position);
    vec3 V = normalize(cameraPosition - position);
    vec3 H = normalize( L + V );

    vLightDir = L;

    vHalfVector = H;

    // diffuse
    vDiffuse = materialDiffuse * lightDiffuse;

    // ambient
    vAmbient = materialAmbient * lightAmbient;

    gl_Position = worldViewProjection * vec4(position, 1.0);

    vec4 ecPos;
    vec3 aux;
    ecPos = worldView * vec4(position, 1.0);
    aux = lightPosition - vec3(ecPos);
    vDist = length(aux);
}
</script>
<script type="x-shader/x-fragment" id="basicLight_spotLight_frag">
#ifdef GL_ES
    precision highp float;
#endif

varying vec3 vDiffuse, vAmbient;
varying vec3 vNormal, vLightDir, vHalfVector;
varying float vDist;

uniform float time;

// lightParameters
vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 lightDiffuse = vec3(1.0, 1.0, 1.0);
vec3 lightSpecular = vec3(1.0, 1.0, 1.0);
vec3 lightAmbient = vec3(0.1, 0.1, 0.1);

float lightConstantAttenuation = 0.1;
float lightLinearAttenuation = 0.05;
float lightQuadraticAttenuation = 0.025;

float lightSpotCosCutoff = 0.75;
vec3 lightSpotDirection = vec3(-4.0, -4.0, -4.0);

// materialPatameters
vec3 materialEmission = vec3(0.7, 0.4, 0.21);
vec3 materialAmbient = vec3(0.1, 0.1, 0.1);
vec3 materialDiffuse = vec3(1.0, 0.5, 0.31);
vec3 materialSpecular = vec3(1.0, 1.0, 1.0);
float materialShininess = 32.0;

void main(void) {
    lightSpotDirection.x = cos(time) * -4.0;
    lightSpotDirection.z = sin(time) * -4.0;

    float NdotL, NdotHV;
    float att, spotEffect;

    vec3 color = vec3(0.0);

    // ambient
    color += vAmbient;

    NdotL = max( dot( vNormal, vLightDir ), 0.0 );
    if (NdotL > 0.0) {
        spotEffect = dot( normalize( lightSpotDirection ), normalize(-vLightDir) );

        if (spotEffect > lightSpotCosCutoff) {
            att = 1.0 / (lightConstantAttenuation + lightLinearAttenuation * vDist + lightQuadraticAttenuation * vDist * vDist);

            // diffuse
            color += vDiffuse * NdotL;

            // specular
            NdotHV = max( dot( vNormal, vHalfVector ), 0.0 );
            color += materialSpecular * lightSpecular * pow( NdotHV, materialShininess );

            color *= att;
        }
    }

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="basicLight_basicTexture_vret">
// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec2 vUV;

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vUV = uv;
}
</script>
<script type="x-shader/x-fragment" id="basicLight_basicTexture_frag">
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;

void main(void) {
    gl_FragColor = texture2D(textureSampler, vUV);
}
</script>

<script type="x-shader/x-vertex" id="npr_tone_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying vec3 vNormal;

void main() {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNormal = normal;
}
</script>
<script type="x-shader/x-fragment" id="npr_tone_frag">
// Varying
varying vec3 vNormal;

vec3 diffuseColor = vec3(1.0, 0.5, 0.31);
vec3 phongColor = vec3(1.0, 0.7, 0.52);
float edge = 0.5;
float phong = 0.9;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    vec3 color = diffuseColor;
    float intensity = dot( lightPosition, vNormal );
    if ( abs( intensity ) < edge ) {
        color = vec3(0.0);
    }
    if ( intensity > phong ) {
        color = phongColor;
    }
    gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="x-shader/x-vertex" id="npr_hatch_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying vec3 vNormal;
varying vec2 vUV;
varying float vLightIntensity;
varying float vV;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    vec3 pos = vec3(worldViewProjection * vec4(position, 1.0));
    vec3 tnorm = normalize( normal );
    vec3 lightDir = normalize( lightPosition - position );

    vLightIntensity = max( dot( lightDir, tnorm ), 0.0 );

    if(uv.s == 0.0 && uv.t == 0.0) {
        vV = pos.y;
    } else {
        vV = uv.t;
    }

    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNormal = normal;
    vUV = uv;
}
</script>
<script type="x-shader/x-fragment" id="npr_hatch_frag">
// Varying
varying vec3 vNormal;
varying vec2 vUV;
varying float vLightIntensity;
varying float vV;

const float frequency = 1.0;

float sWidth = 10.0;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    float dp = length( vec2( dFdx(vV * sWidth), dFdy(vV * sWidth) ) );
    float logdp = -log2(dp);
    float ilogdp = floor(logdp);
    float stripes = exp2(ilogdp);
    float noise = rand(vUV);
    float sawtooth = fract( (vV + noise * 0.01) * frequency * stripes );
    float triangle = abs( 2.0 * sawtooth - 1.0 );
    float transition = logdp - ilogdp;
    triangle = abs( (1.0 + transition) * triangle - transition );

    const float edgeW = 0.2;
    float edge0 = clamp( vLightIntensity - edgeW, 0.0, 1.0 );
    float edge1 = clamp( vLightIntensity, 0.0, 1.0 );

    float square = 1.0 - smoothstep(edge0, edge1, triangle);

    gl_FragColor = vec4(vec3(square), 1.0);
}
</script>

<script type="x-shader/x-vertex" id="npr_gooch_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying float vNdotL;
varying vec3 vReflectVec;
varying vec3 vViewVec;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    vec3 pos = vec3(worldViewProjection * vec4(position, 1.0));
    vec3 tnorm = normalize( normal );
    vec3 lightDir = normalize( lightPosition - position );

    vReflectVec = normalize( reflect( -lightDir, tnorm ) );
    vViewVec = normalize( -pos );
    vNdotL = ( dot( lightDir, tnorm ) + 1.0 ) * 0.5;

    gl_Position = worldViewProjection * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="npr_gooch_frag">
// Varying
varying float vNdotL;
varying vec3 vReflectVec;
varying vec3 vViewVec;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

vec3 surfaceColor = vec3(1.0, 0.5, 0.31);
vec3 warmColor = vec3(1.0, 0.1, 0.0);
vec3 coolColor = vec3(0.0, 0.1, 1.0);
float diffuseWarm = 0.2;
float diffuseCool = 0.1;

void main() {
    vec3 kCool = min(coolColor + diffuseCool * surfaceColor, 1.0);
    vec3 kWarm = min(warmColor + diffuseWarm * surfaceColor, 1.0);
    vec3 kFinal = mix(kCool, kWarm, vNdotL);

    vec3 nReflect = normalize(vReflectVec);
    vec3 nView = normalize(vViewVec);

    float spec = max( dot(nReflect, nView), 0.0 );
    spec = pow(spec, 32.0);

    gl_FragColor = vec4(min(kFinal + spec, 1.0), 1.0);
}
</script>

<script type="x-shader/x-vertex" id="npr_PolkaDot_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying float vLghtIntensity;
varying vec3 vPosition;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);
float specularContribution = 0.7;

void main() {
    vec3 pos = vec3(worldViewProjection * vec4(position, 1.0));
    vec3 tnorm = normalize( normal );
    vec3 lightDir = normalize( lightPosition - position );

    vec3 reflectVec = normalize( reflect( -lightDir, tnorm ) );
    vec3 viewVec = normalize( -pos );

    float diffuseContribution = 1.0 - specularContribution;

    float diffuse = max( dot(lightDir, tnorm), 0.0 );
    float specular = 0.0;
    if (diffuse > 0.0) {
        specular = max( dot(reflectVec, viewVec), 0.0 );
        specular = pow( specular, 16.0 );
    }

    vLghtIntensity = diffuseContribution * diffuse * 1.5 + specularContribution * specular;

    vPosition = position;

    gl_Position = worldViewProjection * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="npr_PolkaDot_frag">
// Varying
varying float vLghtIntensity;
varying vec3 vPosition;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

vec3 spacing = vec3(0.3, 0.3, 0.25);
float dotSize = 0.1;
vec3 modelColor = vec3(1.0);
vec3 PolkaDotColor = vec3(0.0);

void main() {
    float insideSphere, sphereRadius, scaledPointLength;
    vec3 scaledPoint, finalColor;

    scaledPoint = vPosition - (spacing * floor( vPosition / spacing ));
    scaledPoint = scaledPoint - spacing / 2.0;
    scaledPointLength = length(scaledPoint);
    insideSphere = step(scaledPointLength, dotSize);
    finalColor = vec3( mix( modelColor, PolkaDotColor, insideSphere ) );

    gl_FragColor = clamp( vec4(finalColor * vLghtIntensity, 1.0), 0.0, 1.0 );
}
</script>

<script type="x-shader/x-vertex" id="transform_sphereTransform_vert">
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;
uniform float time;

// Varying
varying vec4 vColor;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);
vec3 surfaceColor = vec3(1.0, 0.5, 0.31);
float radius = 1.5;
float blend = 0.1;

const float PI = 3.1415926;
const float TWO_PI = 6.28318;

vec3 sphere(vec2 domain) {
    vec3 range;
    range.x = radius * cos(domain.y) * sin(domain.x);
    range.y = radius * sin(domain.y) * sin(domain.x);
    range.z = radius * cos(domain.x);
    return range;
}

void main() {
    blend = (sin(time) + 1.0) * 0.5;

    vec2 p0 = position.xy * TWO_PI;
    vec3 tnormal = sphere(p0);
    vec3 r0 = radius * tnormal;
    vec3 vertex = r0;
    tnormal = tnormal * blend + normal * (1.0 - blend);
    vertex = vertex * blend + position * (1.0 - blend);
    vec3 lightDir = normalize(lightPosition - vertex);
    float diffuse = max( dot(lightDir, tnormal), 0.0 );
    if (diffuse < 0.125) {
        diffuse = 0.125;
    }
    vColor = vec4(surfaceColor * diffuse, 1.0);
    gl_Position = worldViewProjection * vec4(vertex, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="transform_sphereTransform_frag">
// Varying
varying vec4 vColor;

vec3 lightPosition = vec3(0.0, 4.0, 4.0);

void main() {
    gl_FragColor = vColor;
}
</script>

<script type="x-shader/x-vertex" id="noise_simpleNoise_vert">
// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying float vNoise;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNoise = rand(uv);
}
</script>
<script type="x-shader/x-fragment" id="noise_simpleNoise_frag">
precision highp float;

varying float vNoise;

void main(void) {
    gl_FragColor = vec4(vec3(vNoise), 1.0);
}
</script>

<script type="x-shader/x-vertex" id="noise_PerlinNoise_vert">
// Attributes
attribute vec3 position;
attribute vec2 uv;

// Uniforms
uniform mat4 worldViewProjection;

// Varying
varying float vNoise;

float scale = 5.0;

//
// GLSL textureless classic 3D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

void main(void) {
    gl_Position = worldViewProjection * vec4(position, 1.0);

    vNoise = cnoise( normalize(position) * scale );
}
</script>
<script type="x-shader/x-fragment" id="noise_PerlinNoise_frag">
precision highp float;

varying float vNoise;

void main(void) {
    gl_FragColor = vec4(vec3(vNoise), 1.0);
}
</script>

<div id="outerContainer">
  <div id="subHeaderBackground">
    <div id="templateDropdown" class="dropdownContainer">
      <div class="dropdownLabel">Templates:</div>
      <div class="dropdownSelectContainer">
        <select id="templates">

          <optgroup label="渲染光照">
            <option value="noLight" selected>没有光照(纯色)</option>
            <option value="flat">偏平渲染</option>
            <option value="simplestLight">最简单光照</option>
            <option value="perVertexLighting">逐顶点光照</option>
            <option value="perPixelLighting">逐像素光照</option>
            <option value="pointLight">点光源</option>
            <option value="spotLight">聚光灯</option>
            <option value="basicTexture">加载纹理</option>
          </optgroup>

          <optgroup label="非真实感渲染(NPR)">
            <option value="tone">卡通渲染</option>
            <option value="hatch">影线渲染</option>
            <option value="gooch">Gooch渲染</option>
            <option value="PolkaDot">波尔卡圆点渲染</option>
          </optgroup>

          <optgroup label="变形特效">
            <option value="sphereTransform">球形变形特效</option>
          </optgroup>

          <optgroup label="噪声渲染">
            <option value="simpleNoise">简易噪声(逐顶点)</option>
            <option value="PerlinNoise">柏林噪声(逐顶点)</option>
          </optgroup>

          <!--<option selected>Basic</option>-->
          <!--<option>Black and white</option>-->
          <!--<option>Cell shading</option>-->
          <!--<option>Phong</option>-->
          <!--<option>Discard</option>-->
          <!--<option>Wave</option>-->
          <!--<option>Spherical environment mapping</option>-->
          <!--<option>Fresnel</option>-->
        </select>
      </div>
    </div>
    <div id="meshDropdown" class="dropdownContainer">
      <div class="dropdownLabel">Meshes:</div>
      <div class="dropdownSelectContainer">
        <select id="meshes">
          <option>Sphere</option>
          <option>Torus</option>
          <option>Box</option>
          <option selected="">Torus Knot</option>
          <option>Ground</option>
          <option>schooner</option>
          <option>Tree</option>
          <option>teapot</option>
          <option>monkey</option>
        </select>
      </div>
    </div>
    <div id="buttons">
      <div id="compileButton" class="circleButton" title="Compile"></div>
    </div>
  </div>
  <div id="shadersContainer" style="background-color: green;">
    <div id="vertexRow" class="row">
      <div class="rowHeader">
        <span class="headerTitle">VERTEX SHADER</span>
      </div>
      <div class="rowEditor">
        <div class="shaderCode ace_editor ace-chrome" id="vertexShaderEditor">
          <textarea class="ace_text-input"
                    wrap="off" autocapitalize="off"
                    spellcheck="false"
                    style="opacity: 0; height: 16px; width: 7.20312px; right: 875.797px; bottom: 526px;"></textarea>
        </div>
      </div>
    </div>
    <div id="fragmentRow" class="row">
      <div class="rowHeader">
        <span class="headerTitle">PIXEL (FRAGMENT) SHADER</span>
      </div>
      <div class="rowEditor">
        <div class="shaderCode ace_editor ace-chrome" id="fragmentShaderEditor">
          <textarea class="ace_text-input"
                                                                                          wrap="off"
                                                                                          autocapitalize="off"
                                                                                          spellcheck="false"
                                                                                          style="opacity: 0; height: 16px; width: 7.20312px; right: 882.797px; bottom: 526px;"></textarea>
        </div>
      </div>
    </div>
  </div>
  <div id="renderContainer">
    <div id="loading" class="hidden">Loading...</div>
    <div id="renderCanvasContainer">
      <canvas id="renderCanvas" width="935" height="993" tabindex="1"></canvas>
    </div>
    <div id="errorLog"></div>
  </div>
</div>


</body>
</html>